package etcd3

import (
	"k8s.io/kubernetes/pkg/storage/generic"

	"fmt"
	"github.com/coreos/etcd/clientv3"
	"github.com/golang/glog"
	"golang.org/x/net/context"
	utilruntime "k8s.io/kubernetes/pkg/util/runtime"
	"k8s.io/kubernetes/pkg/watch"
	"sync"
)

// etcdWatcher converts a native etcd watch to a watch.Interface.
type etcd3WatcherRaw struct {
	etcdIncoming  chan *clientv3.WatchResponse
	etcdError     chan error
	ctx           context.Context
	cancel        context.CancelFunc
	etcdCallEnded chan struct{}

	outgoing chan generic.RawEvent
	userStop chan struct{}
	stopped  bool
	emit     func(generic.RawEvent)
	stopLock sync.Mutex
	// wg is used to avoid calls to etcd after Stop()
	wg     sync.WaitGroup
	client *clientv3.Client
}

// newEtcdWatcher returns a new etcdWatcher; if list is true, watch sub-nodes.
// The versioner must be able to handle the objects that transform creates.

func newEtcd3WatcherRaw(list bool, client *clientv3.Client) *etcd3WatcherRaw {
	w := &etcd3WatcherRaw{
		etcdIncoming: make(
			chan *clientv3.WatchResponse, 100),
		etcdError: make(chan error, 1),
		ctx:       nil,
		cancel:    nil,
		outgoing:  make(chan generic.RawEvent),
		userStop:  make(chan struct{}),
		stopped:   false,
		wg:        sync.WaitGroup{},
		client:    client,
	}
	return w
}

// etcdWatch calls etcd's Watch function, and handles any errors. Meant to be called
// as a goroutine.
func (w *etcd3WatcherRaw) etcdWatch(ctx context.Context, key string, resourceVersion uint64) {
	defer utilruntime.HandleCrash()
	defer close(w.etcdError)
	defer close(w.etcdIncoming)

	// All calls to etcd are coming from this function - once it is finished
	// no other call to etcd should be generated by this watcher.
	done := func() {}

	// We need to be prepared, that Stop() can be called at any time.
	// It can potentially also be called, even before this function is called.
	// If that is the case, we simply skip all the code here.
	// See #18928 for more details.
	var watcher clientv3.Watcher
	returned := func() bool {
		w.stopLock.Lock()
		defer w.stopLock.Unlock()
		if w.stopped {
			// Watcher has already been stopped - don't event initiate it here.
			return true
		}
		w.wg.Add(1)
		done = w.wg.Done
		// Perform initialization of watcher under lock - we want to avoid situation when
		// Stop() is called in the meantime (which in tests can cause etcd termination and
		// strange behavior here).
		if resourceVersion == 0 {
			latest, err := etcdGetInitialWatchState(
				ctx,
				*w.client,
				key,
				w.etcdIncoming,
			)

			if err != nil {
				w.etcdError <- err
				return true
			}
			resourceVersion = latest
		}

		opts := etcd.WatcherOptions{
			Recursive:  w.list,
			AfterIndex: resourceVersion,
		}
		watcher = client.Watcher(key, &opts)
		w.ctx, w.cancel = context.WithCancel(ctx)
		return false
	}()
	defer done()
	if returned {
		return
	}

	for {
		resp, err := watcher.Next(w.ctx)
		if err != nil {
			w.etcdError <- err
			return
		}
		w.etcdIncoming <- resp
	}
}

// etcdGetInitialWatchState turns an etcd Get request into a watch equivalent
func etcdGetInitialWatchState(ctx context.Context, client clientv3.Client, key string, incoming chan<- *clientv3.WatchResponse) (resourceVersion uint64, err error) {
	resp, err := client.Get(ctx, key)
	if err != nil {
		return uint64(0), nil
	}
	resourceVersion = resp.Index
	convertRecursiveResponse(resp.Node, resp, incoming)
	return
}

// translate pulls stuff from etcd, converts, and pushes out the outgoing channel. Meant to be
// called as a goroutine.
func (w *etcd3WatcherRaw) translate() {
	defer close(w.outgoing)
	defer utilruntime.HandleCrash()

	for {
		select {
		case err := <-w.etcdError:
			if err != nil {
				var status *unversioned.Status
				switch {
				case etcdutil.IsEtcdWatchExpired(err):
					status = &unversioned.Status{
						Status:  unversioned.StatusFailure,
						Message: err.Error(),
						Code:    http.StatusGone, // Gone
						Reason:  unversioned.StatusReasonExpired,
					}
				// TODO: need to generate errors using api/errors which has a circular dependency on this package
				//   no other way to inject errors
				// case etcdutil.IsEtcdUnreachable(err):
				//   status = errors.NewServerTimeout(...)
				default:
					status = &unversioned.Status{
						Status:  unversioned.StatusFailure,
						Message: err.Error(),
						Code:    http.StatusInternalServerError,
						Reason:  unversioned.StatusReasonInternalError,
					}
				}
				w.emit(generic.RawEvent{
					Type:        watch.Error,
					ErrorStatus: status,
				})
			}
			return
		case <-w.userStop:
			return
		case res, ok := <-w.etcdIncoming:
			if ok {
				if curLen := int64(len(w.etcdIncoming)); watchChannelHWM.Update(curLen) {
					// Monitor if this gets backed up, and how much.
					glog.V(2).Infof("watch: %v objects queued in channel.", curLen)
				}
				w.sendResult(res)
			}
			// If !ok, don't return here-- must wait for etcdError channel
			// to give an error or be closed.
		}
	}
}

func (w *etcd3WatcherRaw) sendResult(res *clientv3.WatchResponse) {
	switch res.Action {
	case EtcdCreate, EtcdGet:
		w.sendAdd(res)
	case EtcdSet, EtcdCAS:
		w.sendModify(res)
	case EtcdDelete, EtcdExpire, EtcdCAD:
		w.sendDelete(res)
	default:
		utilruntime.HandleError(fmt.Errorf("unknown action: %v", res.Action))
	}
}

func (w *etcd3WatcherRaw) sendAdd(res *clientv3.WatchResponse) {
	if res.Node == nil {
		utilruntime.HandleError(fmt.Errorf("unexpected nil node: %#v", res))
		return
	}
	if w.include != nil && !w.include(res.Node.Key) {
		return
	}
	action := watch.Added
	if res.Node.ModifiedIndex != res.Node.CreatedIndex {
		action = watch.Modified
	}
	ev := generic.RawEvent{
		Type: action,
	}
	//copyNode(res.Node, &ev.Current)
	w.emit(ev)
}

func (w *etcd3WatcherRaw) sendModify(res *clientv3.WatchResponse) {
	if res.Node == nil {
		glog.Errorf("unexpected nil node: %#v", res)
		return
	}
	if w.include != nil && !w.include(res.Node.Key) {
		return
	}
	ev := generic.RawEvent{
		Type: watch.Modified,
	}
	//copyNode(res.Node, &ev.Current)
	//copyNode(res.PrevNode, &ev.Previous)
	w.emit(ev)
}

func (w *etcd3WatcherRaw) sendDelete(res *clientv3.WatchResponse) {
	if res.PrevNode == nil {
		utilruntime.HandleError(fmt.Errorf("unexpected nil prev node: %#v", res))
		return
	}
	if w.include != nil && !w.include(res.PrevNode.Key) {
		return
	}
	node := *res.PrevNode
	if res.Node != nil {
		// Note that this sends the *old* object with the etcd index for the time at
		// which it gets deleted. This will allow users to restart the watch at the right
		// index.
		node.ModifiedIndex = res.Node.ModifiedIndex
	}
	ev := generic.RawEvent{
		Type: watch.Deleted,
	}
	//copyNode(&node, &ev.Previous)
	w.emit(ev)
}

// ResultChan implements watch.Interface.
func (w *etcd3WatcherRaw) ResultChan() <-chan generic.RawEvent {
	return w.outgoing
}

// Stop implements watch.Interface.
func (w *etcd3WatcherRaw) Stop() {

}
